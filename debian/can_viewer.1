.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.47.8.
.TH CAN_VIEWER "1" "February 2019" "can_viewer 3.0.0+github" "User Commands"
.SH NAME
can_viewer \- CAN data viewer 3.0.0+github
.SH SYNOPSIS
.B python
\fI\,-m can.viewer \/\fR[\fI\,-h\/\fR] [\fI\,--version\/\fR] [\fI\,-b BITRATE\/\fR] [\fI\,-c CHANNEL\/\fR]
.SH DESCRIPTION
.TP
[\-d {<id>:<format>,<id>:<format>:<scaling1>:...:<scalingN>,file.txt}]
[\-f {<can_id>:<can_mask>,<can_id>~<can_mask>}]
[\-i {iscan,ixxat,kvaser,neovi,nican,pcan,serial,slcan,socketcan,socketcan_ctypes,socketcan_native,usb2can,vector,virtual}]
.PP
A simple CAN viewer terminal application written in Python
.SS "Optional arguments:"
.TP
\fB\-h\fR, \fB\-\-help\fR
Show this help message and exit
.TP
\fB\-\-version\fR
Show program's version number and exit
.TP
\fB\-b\fR, \fB\-\-bitrate\fR BITRATE
Bitrate to use for the given CAN interface
.TP
\fB\-c\fR, \fB\-\-channel\fR CHANNEL
Most backend interfaces require some sort of channel.
For example with the serial interface the channel
might be a rfcomm device: "/dev/rfcomm0" with the
socketcan interfaces valid channel examples include:
"can0", "vcan0". (default: use default for the
specified interface)
.TP
\fB\-d\fR, \fB\-\-decode\fR {<id>:<format>,<id>:<format>:<scaling1>:...:<scalingN>,file.txt}
Specify how to convert the raw bytes into real values.
The ID of the frame is given as the first argument and the format as the second.
The Python struct package is used to unpack the received data
where the format characters have the following meaning:
.TP
< = little\-endian, > = big\-endian
x = pad byte
c = char
? = bool
b = int8_t, B = uint8_t
h = int16, H = uint16
l = int32_t, L = uint32_t
q = int64_t, Q = uint64_t
f = float (32\-bits), d = double (64\-bits)
.TP
Fx to convert six bytes with ID 0x100 into uint8_t, uint16 and uint32_t:
$ python \fB\-m\fR can.viewer \fB\-d\fR "100:<BHL"
.TP
Note that the IDs are always interpreted as hex values.
An optional conversion from integers to real units can be given
as additional arguments. In order to convert from raw integer
values the values are multiplied with the corresponding scaling value,
similarly the values are divided by the scaling value in order
to convert from real units to raw integer values.
Fx lets say the uint8_t needs no conversion, but the uint16 and the uint32_t
needs to be divided by 10 and 100 respectively:
.IP
\f(CW$ python -m can.viewer -d "101:<BHL:1:10.0:100.0"\fR
.TP
Be aware that integer division is performed if the scaling value is an integer.
Multiple arguments are separated by spaces:
.IP
\f(CW$ python -m can.viewer -d "100:<BHL" "101:<BHL:1:10.0:100.0"\fR
.TP
Alternatively a file containing the conversion strings separated by new lines
can be given as input:
.IP
\f(CW$ cat file.txt\fR
.TP
100:<BHL
101:<BHL:1:10.0:100.0
.IP
\f(CW$ python -m can.viewer -d file.txt\fR
.TP
\fB\-f\fR, \fB\-\-filter\fR {<can_id>:<can_mask>,<can_id>~<can_mask>}
Comma separated CAN filters for the given CAN interface:
.TP
<can_id>:<can_mask> (matches when <received_can_id> & mask == can_id & mask)
<can_id>~<can_mask> (matches when <received_can_id> & mask != can_id & mask)
.TP
Fx to show only frames with ID 0x100 to 0x103:
python \fB\-m\fR can.viewer \fB\-f\fR 100:7FC
.IP
Note that the ID and mask are alway interpreted as hex values
.TP
\fB\-i\fR, \fB\-\-interface\fR {iscan,ixxat,kvaser,neovi,nican,pcan,serial,slcan,socketcan,socketcan_ctypes,socketcan_native,usb2can,vector,virtual}
Specify the backend CAN interface to use.
.SS "Shortcuts:"
.HP
+\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
.TP
|
Key   |       Description       |
.HP
+\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
.TP
| ESQ/q
| Exit the viewer         |
.TP
| c
| Clear the stored frames |
.TP
| s
| Sort the stored frames  |
.TP
| SPACE
| Pause the viewer        |
.TP
| UP/DOWN | Scroll the viewer
|
.HP
+\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
